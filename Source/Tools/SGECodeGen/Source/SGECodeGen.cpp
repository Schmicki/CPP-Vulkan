#include "SGECodeGen.h"
#include "Reflection.h"
#include "ClassAnalyzingHelper.h"

#include <iostream>

void processFile(const String& name, const String& path);
void printFile(const String& name, const String& path)
{
	using namespace std;

	cout << path << name << endl;
}

static u32 strHash(const char str[]);
static char* u32toStr(u32 num);

int main(int argc, char** args) {
	using namespace std;

	String path;
	if (argc > 1)
	{
		path = args[1];
	}
	forFilesR(path, { ".h", ".hpp" }, processFile);
}

void processFile(const String& name, const String& path)
{
	using namespace std;

	String _path = path;
	_path.append(name);

	char* buffer;
	u32 fileSize = readToBuffer(_path, buffer);
	if (!fileSize)
	{
		return;
	}

	String code;
	code.append(buffer, fileSize);
	delete[] buffer;

	String genfName;
	name.sub(0, name.findLast('.') + 1, genfName);
	genfName.append("gen.");

	u32 line = 1;
	u32 pos = 0;
	String genFileEnding;

	Array<Class> classes;

	for (; pos < code.size; pos++)
	{
		if (skipAllSpaces(code, pos))
			continue;
		if (skipStuff(code, pos, false))
			continue;

		if (rgxs(code[pos]))
			continue;

		if (genFileEnding.size == 0 && code[pos] == '#')
		{
			// search for .gen file include
			String sub;
			code.sub(pos, pos + 10, sub);
			if (sub.beginsWith("#include"))
			{
				pos += 8;

				if (skipSpaces(code, pos))
				{
					cout << "SGECodeGen: hit end of file while trying to read include!" << endl;
					continue;
				}

				if (code[pos] == '"' || code[pos] == '<')
				{
					pos++;
					u32 begin = pos;
					while (pos < code.size && code[pos] != '"' && code[pos] != '>')
					{
						pos++;
					}

					if (pos == code.size)
					{
						cout << "SGECodeGen: hit end of file while trying to read include!" << endl;
						continue;
					}

					u32 end = pos;

					String iName;
					code.sub(begin, end, iName);

					if (iName.beginsWith(genfName.data))
					{
						iName.sub(iName.findLast('.') + 1, iName.size, genFileEnding);
					}
				}
				else
				{
					cout << "SGECodeGen: expected include file!\n";
					continue;
				}
			}
			else
			{
				pos++;;
				while (pos < code.size && !(code[pos - 1] != '\\' && (code[pos] == '\n' || code[pos] == '\r')))
				{
					pos++;
				}
				pos++;
			}
		}
		else if (genFileEnding.size > 0 && code[pos] == 'C' && pos > 0 ? rgxs(code[pos - 1]) : true)
		{
			// analyze classes
			String sub;
			code.sub(pos, pos + 9, sub);

			if (sub.beginsWith("COMPONENT"))
			{
				pos += 5;
				if (skipSpaces(code, pos))
					continue;

				// get class macro contents
				if (code[pos] != '(')
				{
					cout << "expected ( after 'COMPONENT' MACRO\n";
					continue;
				}

				u32 mbegin = pos++;
				
				if (skipToChar(')', code, pos))
					continue;

				u32 mend = pos;
				pos++;

				// get class name
				u32 nbegin = 0;
				for (; code[pos] != ':' && code[pos] != '{'; pos++)
				{
					if (rgxS(code[pos]) && rgxs(code[pos - 1]))
					{
						nbegin = pos;
					}
				}

				if (nbegin == 0)
				{
					cout << "failed to find class name!\n";
					continue;
				}

				u32 nend;
				for (u32 i = nbegin; rgxS(code[i]) && code[i] != ':' && code[i] != '{'; i++)
				{
					nend = i;
				}

				String className;
				code.sub(nbegin, nend + 1, className);

				u32 index = classes.size;
				classes.add(Class());
				classes[index].name = className;

				// go to class body start
				if (skipToChar('{', code, pos))
					continue;

				analyzeComponent(classes[index], code, pos);
			}
		}
	}
	//cout << "classes: " << classes.size << endl;
	if (classes.size > 0)
	{
		cout << _path << endl;

		String genH = genfName;
		genH.append(genFileEnding, genFileEnding.size);
		String genHPath = path;
		genHPath.append(genH, genH.size);

		String genS = genfName;
		genS.append("cpp", 3);
		String genSPath = path;
		genSPath.append(genS, genS.size);

		//cout << genHPath << endl;
		//cout << genSPath << endl;

		char* buffer;
		u32 hFileSize = readToBuffer(genHPath, buffer);

		if (hFileSize > 0 && false)
		{
			//cout << "write old!" << endl;
		}
		else
		{
			//cout << "write new!" << endl;
			String headerFile;
			String sourceFile;

			headerFile.append("/*\n* This file was generated by the SGE Code Gen.\n* Please dont edit this file manually. \n*/\n\n");
			sourceFile.append("/*\n* This file was generated by the SGE Code Gen.\n* Please dont edit this file manually. \n*/\n\n");

			sourceFile.append("#include \"Core.h\"");
			sourceFile.append("\n");
			sourceFile.append("#include \"");
			sourceFile.append(name);
			sourceFile.append("\"\n\n");
			sourceFile.append("using namespace sge;");
			sourceFile.append("\n\n");

			for (u32 i = 0; i < classes.size; i++)
			{
				Class& clazz = classes[i];
				String id{ u32toStr(rrand32u()) };
				String hsh{ u32toStr(strHash(clazz.name)) };

				headerFile.append("#if defined(");
				headerFile.append(clazz.name);
				headerFile.append("_GENERATED)\n");
				headerFile.append("    #undef ");
				headerFile.append(clazz.name);
				headerFile.append("_GENERATED\n#endif\n");
				headerFile.append("#define ");
				headerFile.append(clazz.name);
				headerFile.append("_GENERATED()\\\n");
				headerFile.append("static sge::Class* type();\n");
				headerFile.append("\n");

				sourceFile.append("Class* construct");
				sourceFile.append(clazz.name);
				sourceFile.append("Class()\n{\n");
				sourceFile.append("    Class* clazz = new Class();\n");
				sourceFile.append("    clazz->uid = { ");
				sourceFile.append(id);
				sourceFile.append(", ");
				sourceFile.append(hsh);
				sourceFile.append("};\n");
				sourceFile.append("    clazz->name = \"");
				sourceFile.append(clazz.name);
				sourceFile.append("\";\n");
				sourceFile.append("    clazz->size = sizeof(");
				sourceFile.append(clazz.name);
				sourceFile.append(");\n");
				sourceFile.append("return clazz;\n");
				sourceFile.append("}\n\n");
				sourceFile.append("Class* ");
				sourceFile.append(clazz.name);
				sourceFile.append("::type()\n{\n");
				sourceFile.append("    static Class* clazz = construct");
				sourceFile.append(clazz.name);
				sourceFile.append("Class();\n");
				sourceFile.append("    return clazz;\n");
				sourceFile.append("}");
				sourceFile.append("\n");
			}

			cout << writeToFile(genHPath, headerFile, headerFile.size, false) << endl;
			cout << writeToFile(genSPath, sourceFile, sourceFile.size, false) << endl;
		}
	}
}

u32 strHash(const char str[])
{
	u32 len = String::length(str);
	u32 value = { 0 };
	for (u32 i = 0; i < len; i++)
	{
		value = 3 * value + str[i];
	}
	return value;
}

char* u32toStr(u32 num)
{
	using namespace std;

	u32 count = 0;
	char digits[10];
	while (num)
	{
		u32 n = num;
		num /= 10;

		digits[9 - count] = n - (num * 10) + '0';
		count++;
	}
	u32 off = 10 - count;
	char* ret = new char[count + 1];
	ret[count] = 0;
	for (u32 i = 0; i < count; i++)
	{
		ret[i] = digits[i + off];
	}
	return ret;
}